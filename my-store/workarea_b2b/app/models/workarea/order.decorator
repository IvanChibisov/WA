module Workarea
  decorate Order, with: :b2b do
    decorated do
      field :account_id, type: String
      field :reviewed_at, type: Time
      field :reviewed_by_id, type: String
      field :review_notes, type: String

      index(account_id: 1)
      index(reviewed_at: 1, placed_at: 1)
      scope :for_account, ->(account_id) { where(account_id: account_id.to_s) }
      scope :pending_review, -> { where(reviewed_at: nil, :placed_at.gt => Time.at(0)) }
    end

    class_methods do
      def recent_for_account(account_id, limit = 3)
        for_account(account_id)
          .where(:placed_at.gt => Time.at(0))
          .order(placed_at: :desc)
          .limit(limit)
      end

      def pending_for_account(account_id, limit = 3)
        pending_review.for_account(account_id).order(placed_at: :desc).limit(limit)
      end
    end

    def reviewed?
      account_id.blank? || reviewed_at.present?
    end

    def auto_reviewed?
      reviewed? && reviewed_by_id.blank?
    end

    def review!(user_id = nil, notes = nil)
      update(
        reviewed_at: Time.current,
        reviewed_by_id: user_id,
        review_notes: notes
      )
    end
    alias_method :decline!, :review!

    def approve!(user_id = nil, notes = nil)
      run_callbacks :place do
        review!(user_id, notes)
      end
    end

    def reset_checkout!
      self.account_id = nil
      super
    end

    # Do not run callbacks if account order, they will be run if approved
    # during review.
    def place
      return super unless purchasable? && account_id.present?

      self.placed_at = Time.current
      with(write: { w: "majority", j: true }) { save }
    end
  end
end
